using Ploeh.AutoFixture;
using Ploeh.AutoFixture.AutoMoq;
using Ploeh.AutoFixture.Kernel;
using Ploeh.AutoFixture.Xunit2;
using System.Collections.Generic;
using System.Web.Mvc;

namespace Tests.Core
{
	public class AutoMoqDataAttribute : AutoDataAttribute
	{
		// https://stackoverflow.com/questions/12425521/force-autofixture-to-use-the-greediest-constructor
		// use greediest constructor not for string, int, etc
		private class GreedyEngineParts : DefaultEngineParts
		{
			public override IEnumerator<ISpecimenBuilder> GetEnumerator()
			{
				var iter = base.GetEnumerator();
				while (iter.MoveNext())
				{
					if (iter.Current is MethodInvoker)
						yield return new MethodInvoker(
							new CompositeMethodQuery(
								new GreedyConstructorQuery(),
								new FactoryMethodQuery()));
					else
						yield return iter.Current;
				}
			}
		}

		// mvc controllers initialization
		private class MvcCustomization : ICustomization
		{
			public void Customize(IFixture fixture)
			{
				fixture.Customize<ControllerContext>(c => c
					.Without(x => x.DisplayMode));
			}
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="greedyConstructor">When AutoFixture creates complex objects it invokes the constructors of the types in question. When a class exposes more than one constructor, the default behavior is to pick the constructor with the fewest number  of arguments. This is the exact opposite of most DI Containers that select the greediest constructor.</param>
		public AutoMoqDataAttribute(/*bool greedyConstructor = false, */int repeatCount = 3)
			: base(new Fixture(new GreedyEngineParts())
					.Customize(new AutoMoqCustomization())
					//.Customize(new AutoConfiguredMoqCustomization()) // - should automatically configure all mocks so that their members' return values are generated by AutoFixture
					.Customize(new MvcCustomization())
				  )
		{
			// change number of element in collections:
			if (repeatCount != 3)
			{
				Fixture.RepeatCount = repeatCount;
			}
		}
	}
}
